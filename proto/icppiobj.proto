/* Interpreting C++, executing the source and executable like a script */
/* By Jesse Liu < neoliu2011@gmail.com >, 2024 */
/* Copyright (c) vpand.com 2024. This file is released under LGPL2.
   See LICENSE in root directory for more details
*/

syntax = "proto3";

package com.vpand.icppiobj;

enum ArchType {
  Unsupported = 0;
  X86_64 = 1;
  AArch64 = 2;
}

enum ObjectType {
  MachO_Reloc = 0;
  MachO_Exe = 1;
  ELF_Reloc = 2;
  ELF_Exe = 3;
  COFF_Reloc = 4;
  COFF_Exe = 5;
}

message DynSection {
  string name = 1; // section name
  uint32 size = 2; // section size
  uint32 rva = 3;  // rva address in file
};

message SymbolList {
  repeated string names = 1; // for dependent module
  repeated uint32 rvas = 2;  // for object itself
}

/*
icpp interpretable object file
it's a kind of runtime cache file to make icpp run faster
e.g.:

full workflow: 
  source.cc --compile--> object --parse--> iobject --interpret--> done

cache workflow:
  source.cc --load|source.cc.io--> iobject -->interpret--> done

As we can see, the skipping of compile and parse stages which are very
expensive at runtime will make icpp run much faster next time with
the same C++ source script.
*/
message InterpObject {
  // io file header
  uint32 magic = 1;
  uint32 version = 2;
  // architecture and orignal object file type
  ArchType arch = 3;
  ObjectType otype = 4;
  /*
  map <name, rva> of the internal functions and datas
  */
  map<string, uint32> funcs = 5;
  map<string, uint32> datas = 6;
  // text section information
  uint32 textsecti = 7;
  uint32 textsz = 8;
  uint32 textrva = 9;

  // dynamically allocated section, e.g.: bss common
  repeated DynSection dynsects = 10;

  // instruction details, e.g.: type, reloc, length, etc.
  repeated uint64 instinfos = 11;
  // decoded instruction operand meta datas
  map<string, bytes> instmetas = 12;

  // map <module, symbols> of the instruction relocation symbols
  map<string, SymbolList> irefsyms = 13;
}
